#include <iostream>

// Добавляем по очереди вершины
// в сбалансированное дерево поиска,
// проходим по всем вершинам в порядке возрастания.

// Лучшее время: O(n)
// Среднее время: O(n log n)
// Худшее время: O(n^2)O(n log n)
// Дополнительная память: O(n)
// Стабильность: да

// сортировка бинарным деревом
struct TreeNode // структура для представления узлов дерева
{
    int value; // значение в узле
    TreeNode *left; // указатель на левое поддерево
    TreeNode *right; // указатель на правое поддерево

    TreeNode(int val) : value(val), left(nullptr), right(nullptr) {} 
    /* конструктор для создания вершины дерева с заданным значением 
    и нулевыми указателями на левое и правое поддерево */
};

void insert(TreeNode *&root, int value) // вставка вершины в дерево поиска
{
    if (root == nullptr) // если дерево пустое - создаем корень
    {
        root = new TreeNode(value); // создаем вершину с заданным значением
    }
    else if (value < root->value) // если значение меньше значения корня - вставляем в левое поддерево
    {
        insert(root->left, value); // рекурсивно вызываем функцию для левого поддерева
    }
    else
    {
        insert(root->right, value); // рекурсивно вызываем функцию для правого поддерева
    }
}

/* обход дерева в порядке возрастания и сохранение в отсортированном порядке в массиве arr */
void traverseInOrder(TreeNode *root, int *arr, int &index) 
{
    if (root == nullptr) // если дерево пустое - выходим из функции
    {
        return; // выход из функции
    }
    traverseInOrder(root->left, arr, index); // рекурсивно вызываем функцию для левого поддерева
    arr[index++] = root->value; // сохраняем значение вершины в массиве
    traverseInOrder(root->right, arr, index); // рекурсивно вызываем функцию для правого поддерева
}

void treesort(int *arr, int size) // сортировка бинарным деревом 
{
    TreeNode *root = nullptr; // создаем пустое дерево поиска (корень - nullptr)

    // Создание бинарного дерева
    for (int i = 0; i < size; i++)
    {
        insert(root, arr[i]); // вставляем вершину в дерево поиска с заданным значением
    }

    // Обход дерева в порядке возрастания и сохранение в отсортированном порядке
    int index = 0;
    /* обходим дерево в порядке возрастания и сохраняем в отсортированном порядке в массиве arr */
    traverseInOrder(root, arr, index);
}

// заправшиваем размер массива
// просим ввести элементы массива
// выводим введенный массив
// вызываем функцию сортировки
// выводим отсортированный массив
int main()
{
    int size;
    std::cout << "Введите размер массива: ";
    std::cin >> size;
    int arr[size];
    std::cout << "Введите элементы массива: \n";
    for (int i = 0; i < size; i++)
    {
        std::cin >> arr[i];
    }
    std::cout << "Начальный массив: ";
    for (int i = 0; i < size; i++)
    {
        std::cout << arr[i] << " ";
    }
    treesort(arr, size);
    std::cout << "\nОтсортированный массив: ";
    for (int i = 0; i < size; i++)
    {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n";
}